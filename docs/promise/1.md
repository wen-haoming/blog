## 高阶函数

> 一个函数的参数 是一个函数(回调)
>
> 一个函数返回一个函数 (拆分函数)



## 例子

 **1.  before**

```javascript
// 能够在目标函数执行前传入自定义功能的函数提前执行
// 特点: 返回一个函数来按需执行
Function.prototype.before = function(fn){
    let that = this
    return function(...args){
        fn.call(this)
        that.apply(this,args)
    }
}
```

**2. 事务**

```javascript
// 事务 开始的时候 做某件事 结束的时候在做某件事
// 特点: 封装一个函数,来做一个函数执行的中转过程
const perform = (anymethod,wrappers)=>{
    wrappers.forEach(wrap=>{
        wrap.initilizae();
    })
    anymethod();
    wrappers.forEach(wrap=>{
        wrap.close();
    })
}
perform(()=>{
    console.log('说话')
},[
    { // warpper
        initilizae(){
            console.log('您好')
        },
        close(){
            console.log('再见')
        }
    },
    { // warpper
        initilizae(){
            console.log('您好1')
        },
        close(){
            console.log('再见2')
        }
    }
])
// 柯里化 我们可以把一个大函数拆分成很多的具体的功能
```

**3. 柯里化**

​	**3.1 类型判断**

```javascript
// 特点：一开始就把需要的参数给存起来，下次需要就返回原来的配置参数
const checkType = (type) => {
  return (content) => {
    return Object.prototype.toString.call(content) === `[object ${type}]`
  }
}
const unit = {}
const types = ['Number', "Object", 'Boolean']
types.forEach((type) => {
  unit['is' + type] = checkType(type)
})
console.log(unit.isNumber(123))
```

​	**3. 2柯里化函数**

```javascript
// 特点: 把参数都存起来利用函数的length来做判断依据
const curring = (fn, ...arr) => {
  let len = fn.length
  return (...args) => {
    arr = arr.concat(args)
    if (arr.length >= len) {
      return fn(...arr)
    }
    return curring(fn, ...arr)
  }
}
```

**4. after**

```javascript
// 特点: 设置返回函数的执行条件（设置计时器来延迟加载目标函数）
const after = (times, fn) => {
  return () => {
    if (--times === 0) {
      fn()
    }
  }
}

```

**4.1 计时器** -->并发问题的解决方案

```javascript
// 特点: 设置一个容器函数， 把需要执行多次设置好，满足多少次之后就执行相对应的函数。 并且在异步的回调函数中执行调用，能够有效指导执行了多少次。
const fs = require("fs")
let school = {}
const after = (times, fn) => () => --times === 0 && fn()
let fn = after(2, () => {
  console.log(school)
})

fs.readFile('./a.txt', 'utf8', (err, data) => {
  school['a.txt'] = data
  fn()
})
fs.readFile('./a.txt', 'utf8', (err, data) => {
  school['a.txt'] = data
  fn()
})
```

**5. 发布订阅模式**

```javascript
// 特点：需要事先准备好一个event，把订阅函数$on进去之后，根据相关的时间点然后再$emit出来
// after的区别是少了一个存储对应函数的地方，且单一, 并且发布订阅能够灵活控制时机执行对应的函数。
const fs = require("fs")
const event = {
  arr: {},
  $on: function (event, fn) {
    this.arr[event] ? this.arr[event].push(fn) : (this.arr[event] = [fn])
  },
  $emit: function (event) {
    this.arr[event] && this.arr[event].forEach((ele) => ele())
  }
}
fs.readFileSync('a.txt', 'utf8', (err, data) => {
  event.$on('input', () => {
    console.log(data)
  })
})
fs.readFileSync('b.txt', 'utf8', (err, data) => {
  event.$on('input', () => {
    console.log(data)
  })
})

```

​	**6.观察者模式**

 ```javascript
// 特点：主体是被观察者 并且 把观察者放进被观察者里面，
// 被观察者的一切变化都会通知观察者的变化
// 与发布订阅类似，不过
class Subject {
  constructor() {
    this.arr = []
    this.state = null
  }
  attach (obj) {
    this.arr.push(obj)
  }
  setState (state) {
    if (this.state !== state) {
      this.state = state
      this.arr.forEach(obj => obj.upData(state))
    }
  }
}

class Observer {
  constructor(name) {
    this.name = name
  }
  upData (state) {
    console.log('我叫' + this.name + '，观察者的状态发生变化，从而我接受到了state的值为 ' + state)
  }
}

// sub被观察者把观察者注入到自身上，当自身的状态发生改变就直接通知obs
let sub = new Subject()
sub.attach(new Observer('小明'))
sub.attach(new Observer('小红'))
sub.setState("我很好")

 ```

