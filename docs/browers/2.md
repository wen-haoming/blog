## 浏览器的事件循环系统
  ### 首先浏览器是单线程的，并非是多线程的
  1. 当浏览器在渲染页面的同时也加载js脚本代码的时候,通常我们的js脚本代码都会操作dom的节点, 并且多个js脚本代码同时工作的话我们的浏览器根本不清楚听哪一个命令去渲染对应dom, 所以浏览器推出后从执行原理上已经规定了它只能是单线程。
  2. 单线程的概念是只有一个主要的运行线程，并不代表只有一个线程。关于线程和进程的概念可以查看上一篇的文章介绍。
  + 单线程就每个任务都需要等待上一个任务的完成
  + 浏览器的执行过程都是不断循环执行栈的任务
  + 从每个任务的执行特性分为同步任务和异步任务
    + 同步任务通常都会第一时间存放到执行栈中优先执行
    + 每个异步任务则会存放到任务队列
  + 循环机制是不断读取执行栈中的任务并且依次执行
  
以上就是浏览器的基本运行概括
> 浏览器的事件循环图
![浏览器事件循环](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png)
---


### 任务队列/消息队列
  #### 1. 为什么浏览器需要任务队列来处理异步的代码?
 从浏览器的发展角度划分需要经历几个阶段
   1. 从一开始就确定的代码可以使用一个**执行栈**单线程来按照顺序来依次执行
   2. 如果需要在线程的基础上继续添加新的任务,需要引入循环语句和**事件循环**
   3. 如果需要接受其他线程的任务,就引入了**消息队列**

  #### 2. 从消息队列的分类
  我们知道从消息队列的分类又有**宏任务**和**微任务**

  - 微任务： promise.then ，MutationObserver，
  - 宏任务：script ，ajax ， 事件，requestFrameAnimation， setTimeout ，setInterval ，setImmediate （ie下），MessageChannel ，UI rendering。

  ### 3. 微任务和宏任务在运行中有什么区别？
  * 当前主栈全部执行完毕后 清空微任务 ，会取出一个宏任务
  *  执行完毕后 继续清空微任务 -> 无线循环
  ```javascript
    async function async1 () {
  console.log('async1 start')
  await async2()
  console.log("async1 end")
  }
  async function async2 () {
    console.log('async2')
  }
  console.log('script start')
  setTimeout(function () {
    console.log('setTimeout')
    Promise.resolve('setTimeout end').then(data => console.log(data))
  }, 0)
  setTimeout(function () {
    console.log('setTimeout2')
    Promise.resolve('setTimeout2 end').then(data => console.log(data))
  }, 100)
  async1(); // 执行完async 1 就结束了
  new Promise(function (resolve) {
    console.log('promise1')
    resolve();
  }).then(function () {
    console.log('promise2')
    return 'promise2 end'
  }).then((data) => console.log(data))
  console.log('script end')
  // script start
  // async1 start
  // async2
  // promise1
  // script end
  // async1 end
  // promise2
  // setTimeout
  ```
  ### 4. 为什么又会有微任务的诞生呢？

