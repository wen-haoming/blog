# 闭包

>  闭包涉及 作用域 作用域链 执行上下文 内存管理等多个知识点

## 作用域

> 用于确定特定场景下如何查找变量
> **全局作用域 函数作用域块级作用域**

    暂存性死区   变量提升  全局声明
    作用域链

## 执行上下文

> 当前执行的环境/作用域，和作用域链相辅相成，执行上下文包含作用域链

**代码执行的两个阶段**

### 代码预编译阶段 （这个时候将 js 代码编译成可执行代码）

1.  预编译阶段进行变量声明；
2.  预编译阶段变量声明进行提升，但是值为 undefined；
3.  预编译阶段所有非表达式的函数声明进行提升。

### 代码执行阶段 （执行代码，执行上下文阶段全部创建完成）

作用域在预编译阶段确定，但是作用域链是在执行上下文的创建阶段完全生成的。因为函数在调用时，才会开始创建对应的执行上下文。执行上下文包括了：变量对象、作用域链以及 this的指向


## 闭包

    函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可访问，就形成了闭包。
    闭包的好处：
      1. 实现模块化
      2. 私有化变量
      3. 公共变量
      4. 做缓存


## 内存管理

  

> **栈空间** 由操作系统自动分配释放，存放函数的参数值，局部变量的值，

        **堆空间**  一般由开发者分配释放，这部分空间就要考虑垃圾回收问题。

**对于分配内存和读写内存的行为所有语言都较为一致，但释放内存空间在不同语言之间有差异。**例如，JavaScript 依赖宿主浏览器的垃圾回收机制，一般情况下不用程序员操心。但这并不表示万事大吉，某些情况下依然会出现内存泄漏现象。
设置 null 可以清除

## 实现单例模式


> 保证一个类只有一个实例，并且提供一个访问它的全局访问点。

```
function Person() { this.name = 'lucas' }
const getSingleInstance = (function(){
var singleInstance
   return function() {
    if (singleInstance) {
    return singleInstance
         }
   return singleInstance = new Person()
         }
 })()
const instance1 = new getSingleInstance()
const instance2 = new getSingleInstance()
```

## 实现发布订阅模式

## 实现观察者模式
