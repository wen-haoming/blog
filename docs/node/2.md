## node实现模块化原理

 	1. 命名空间，防止命名冲突 -- 无法彻底解决命名问题
 	2. 自执行函数 node 让js 拥有了服务端执行的能力，可以读写文件

node能实现commonJs规范依赖于**文件的读写**

fs.readFileSync --读文件

fs.accessSync -- 查看文件是否存在

```javascript
// path模块
// resolve 出来的一定是一个绝对路径
// join 就是以/拼接
// 如果有 / 只能用join
	const path = require('path')
  path.resolve(__dirname, '/a','/c')
  path.join(__dirname, '/a','/c')
// 取扩展名
	path.extname('main.js')
// 直接取名
	path.basename('main.js')
// 取父路径
	path.dirname(__dirname)

```



###  2.1 路径分析和文件定位

路径分析-模块标识

  + 核心模块 如http，fs，path等  **速度最快**
  + . 或 . . 的相对路径文件模块 **速度第二**
  + / 开头的绝对路径文件模块 **速度第二**
  + 非路径的自定义connect模块 **速度最慢** 在当前文件延上层查找查找到node_Modules里面

文件定位

​	nodeJs分析标识符的过程，会按照.js .json .node的次序补足扩展名依次尝试

诀窍：

	1. 如果是.node 和.json 文件 在传递给require的标识符带上扩展名能加快一点速度。
 	2. 同步配合缓存，可以大幅度缓解node单线程中阻塞式调用的缺陷。 

如果require分析文件扩展名得到一个目录，则会去package.json文件的main.js属性去查找对应的文件