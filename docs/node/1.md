##  node基本
### 1. node 基本概述
web 服务器的特点： 事件驱动，非阻塞io

node的特点：异步io，事件驱动，单线程，

- 异步io： 极大提升运行效率
- 事件驱动：函数是第一公民，回调函数是最好接受异步调用返回数据的方式
- 单线程：js与其他线程无法共享状态，没有状态同步，死锁，也没有线程上下文交换所带来的性能上的开销。
  -  缺点：
  - 1，无法利用多核cpu。
  - 2，错误会引起整个应用退出。
  - 3，大量cpu导致无法继续调用异步io。
- 跨平台

node是一个js的运行时，绝大多数操作都是异步方式进行调用，

node 能干什么？

​	写脚本代码，中间层，服务端渲染，前后端分离

### 2. node进程和线程的区别 (node中的进程) 多核 开启子进程 pm2

一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等 ,进程表示一个程序，线程是进程中的单位  主线程只有一个 

1个进程可以占用1核cpu

- 多线程在单核cpu中其实也是顺序执行的，不过系统可以帮你切换那个执行而已，没有提高速度

- 多核cpu的话就可以在多个cpu中同时执行

> 单线程优点：解决切换上下文时间,锁的问题,节省内存 (多线程)

> node 主进程，在开多个子进程，里面包含着一个线程





### 3. node的global基本属性(常用))

1. global 中的属性为全局属性。 在全局声明的
2. 默认this的指向为模块环境。this === module.exports (因为模块环境的this被改变)

```javascript
  以上为模块参数
    (function(module, exports, require,  __dirname, __filename){

    })()
    process（进程） buffer（二进制数据）
    ckearInterval setInterval
    clearTimeout setTimeout
    clearImmediate setImmediate 宏任务
//  以上为global 参数
```

#### global.precess(进程属性)

 1. **precess.argv** 为用户执行文件是传入的参数 node + 文件名  < 参数 >


    ```javascript
      process.argv.slice(2) 需要从第二位开始截取
      //获取参数 使用reduce来对处理到我需要的对象
      let config = process.argv.slice(2).reduce((pre, cur, index, arr) => {
        if (cur.includes('--')) {
          pre[cur] = arr[index + 1]
        }
        return pre
      }, {})
      console.log(config)
    ```
     使用commander 来自定义命令行
     使用chalk 来自定义命令行颜色
  ```javascript
      npm i commander -D
      
      const program = require("commander")
        最后都需要加入.parse(process.argv)
      
      1. 设置属性
      program.option(' -p , --port  <val> ', 'set port ')
      1. 设置命令
        program.command('create')
          .alias("c")
          .description("haha")
          .action(() => {
            console.log("success")
          })
      2. 订阅输入某件事
        program.on('--help',()=>{
            console.log(111)
        })
      3. cholk粉笔
          cholk.green(str)
  ```
  关于commander的命令参数可以看后续的文章讲解

 2. **process.platform** (查看node的平台参数)


    window => 32win

    mac => darwin

3. **process.cwd**(返回当前的执行的工作目录)  
  
  命令中在哪执行就在指向哪里
  ```javascript
    path.resolve() // 解析出一个绝对路径
    process.cwd() // 在哪里执行这个文件,目录就是哪里,代表的就是执行的文件
  ```


4. **process.env**(可以根据环境的不同执行不同的结果)


   ```javascript
    export NODE_ENV=prod && node xxx.js
    那么当前的process.env.NODE_ENV = prod
    // process.env.NODE_ENV = ‘develop’
   ``` 


5. **process.nextTick**(node中的微任务)))


   **timer --> poll -->  check**

   node中的微任务

   宏任务 -> **setImmediate( fn )**  vs  **setTimeout** 



```
      ┌───────────────────────┐
  ┌─> │        timers         │ 本阶段执行setTimeout() 和 setInterval() 
  │   └──────────┬────────────┘
  │   ┌──────────┴────────────┐
  │   │     I/O callbacks     │ 这个阶段执行一些诸如TCP错误之类的系统操作的回调
  │   └──────────┬────────────┘
  │   ┌──────────┴────────────┐
  │   │     idle, prepare     │ 只内部使用
  │   └──────────┬────────────┘      ┌───────────────┐
  │   ┌──────────┴────────────┐      │   incoming:   │
  │   │         poll          │  <───┤  connections, │ 获取新的 I/O 事件,查找已经到时的定时器
  │   └──────────┬────────────┘      │   data, etc.  │
  │   ┌──────────┴────────────┐      └───────────────┘
  │   │        check          │ setImmediate()
  │   └──────────┬────────────┘
  │   ┌──────────┴────────────┐
  └──-┤    close callbacks    │ 关闭事件的回调 socket.close事件
      └──────────────────────—┘

      定时器：本阶段执行已经安排的 setTimeout() 和 setInterval() 的回调函数。
      待定回调：执行延迟到下一个循环迭代的 I/O 回调。
      idle, prepare：仅系统内部使用。
      轮询：检索新的 I/O 事件;执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，它们由计时器和 setImmediate() 排定的之外），其余情况 node 将在此处阻塞。
      检测：setImmediate() 回调函数在这里执行。
      关闭的回调函数：一些准备关闭的回调函数，如：socket.on('close', ...)。
      
```


[node官方中文翻译](https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/)
> 注意：如果只有setTimeout 0秒状态和setImmediate两个 有时候可能是setImmediate优先

> 受node的性能影响，不一定谁先执行，但是**setImmediate是在i/o之后立即执行**

> poll 和check 执行都会自动执行微任务


