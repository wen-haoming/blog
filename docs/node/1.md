##  node基本
### 1. node 基本概述
web 服务器的特点： 事件驱动，非阻塞io

node的特点：异步io，事件驱动，单线程，

- 异步io： 极大提升运行效率
- 事件驱动：函数是第一公民，回调函数是最好接受异步调用返回数据的方式
- 单线程：js与其他线程无法共享状态，没有状态同步，死锁，也没有线程上下文交换所带来的性能上的开销。
  -  缺点：
  - 1，无法利用多核cpu。
  - 2，错误会引起整个应用退出。
  - 3，大量cpu导致无法继续调用异步io。
- 跨平台

node是一个js的运行时，绝大多数操作都是异步方式进行调用，

node 能干什么？

​	写脚本代码，中间层，服务端渲染，前后端分离

### 2. node进程和线程的区别 (node中的进程) 多核 开启子进程 pm2

一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等 ,进程表示一个程序，线程是进程中的单位  主线程只有一个 

1个进程可以占用1核cpu

- 多线程在单核cpu中其实也是顺序执行的，不过系统可以帮你切换那个执行而已，没有提高速度

- 多核cpu的话就可以在多个cpu中同时执行

> 单线程优点：解决切换上下文时间,锁的问题,节省内存 (多线程)

> node 主进程，在开多个子进程，里面包含着一个线程





### 3. node的global基本属性(常用))

1. global 中的属性为全局属性。 在全局声明的
2. 默认this的指向为模块环境。this === module.exports (因为模块环境的this被改变)

```javascript
  以上为模块参数
    (function(module, exports, require,  __dirname, __filename){

    })()
    process（进程） buffer（二进制数据）
    ckearInterval setInterval
    clearTimeout setTimeout
    clearImmediate setImmediate 宏任务
//  以上为global 参数
```

#### global.precess(进程属性)

 1. **precess.argv** 为用户执行文件是传入的参数 node + 文件名  < 参数 >
    ```javascript
      process.argv.slice(2) 需要从第二位开始截取
      //获取参数 使用reduce来对处理到我需要的对象
      let config = process.argv.slice(2).reduce((pre, cur, index, arr) => {
        if (cur.includes('--')) {
          pre[cur] = arr[index + 1]
        }
        return pre
      }, {})
      console.log(config)
    ```
     使用commander 来自定义命令行
     使用chalk 来自定义命令行颜色
  ```javascript
      npm i commander -D
      
      const program = require("commander")
        最后都需要加入.parse(process.argv)
      
      1. 设置属性
      program.option(' -p , --port  <val> ', 'set port ')
      1. 设置命令
        program.command('create')
          .alias("c")
          .description("haha")
          .action(() => {
            console.log("success")
          })
      2. 订阅输入某件事
        program.on('--help',()=>{
            console.log(111)
        })
      3. cholk粉笔
          cholk.green(str)
  ```
  关于commander的命令参数可以看后续的文章讲解
  
 2. **process.platform** 查看node的平台参数


    window => 32win

    mac => darwin
   

  



1. cwd

   process.cwd 在哪里执行此文件

   其实path.resolve() 和它的效果一样也能解析出相同路径

2. env

   可以根据环境的不同执行不同的结果

   process.env.NODE_ENV = ‘develop’

3. Process.nextTick( fn )

   **timer --> poll -->  check**

   node中的微任务

   宏任务 -> **setImmediate( fn )**  vs  **setTimeout** 

   受node的性能影响，不一定谁先执行，但是**setImmediate是在i/o之后立即执行**

 执行顺序例子

```javascript
setTimeout(()=>{
    console.log('timer'+1); // 2
    Promise.resolve().then(()=>{
        console.log('then1') // 3
    })
})
Promise.resolve().then(()=>{
    console.log('then2'); // 1
    setTimeout(()=>{
        console.log('timer'+2); // 4
    })
});



```


