(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{268:function(t,a,e){"use strict";e.r(a);var n=e(38),r=Object(n.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包","aria-hidden":"true"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),e("blockquote",[e("p",[t._v("闭包涉及 作用域 作用域链 执行上下文 内存管理等多个知识点")])]),t._v(" "),e("h2",{attrs:{id:"作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域","aria-hidden":"true"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),e("blockquote",[e("p",[t._v("用于确定特定场景下如何查找变量\n"),e("strong",[t._v("全局作用域 函数作用域块级作用域")])])]),t._v(" "),e("pre",[e("code",[t._v("暂存性死区   变量提升  全局声明\n作用域链\n")])]),t._v(" "),e("h2",{attrs:{id:"执行上下文"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文","aria-hidden":"true"}},[t._v("#")]),t._v(" 执行上下文")]),t._v(" "),e("blockquote",[e("p",[t._v("当前执行的环境/作用域，和作用域链相辅相成，执行上下文包含作用域链")])]),t._v(" "),e("p",[e("strong",[t._v("代码执行的两个阶段")])]),t._v(" "),e("h3",{attrs:{id:"代码预编译阶段-（这个时候将-js-代码编译成可执行代码）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码预编译阶段-（这个时候将-js-代码编译成可执行代码）","aria-hidden":"true"}},[t._v("#")]),t._v(" 代码预编译阶段 （这个时候将 js 代码编译成可执行代码）")]),t._v(" "),e("ol",[e("li",[t._v("预编译阶段进行变量声明；")]),t._v(" "),e("li",[t._v("预编译阶段变量声明进行提升，但是值为 undefined；")]),t._v(" "),e("li",[t._v("预编译阶段所有非表达式的函数声明进行提升。")])]),t._v(" "),e("h3",{attrs:{id:"代码执行阶段-（执行代码，执行上下文阶段全部创建完成）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#代码执行阶段-（执行代码，执行上下文阶段全部创建完成）","aria-hidden":"true"}},[t._v("#")]),t._v(" 代码执行阶段 （执行代码，执行上下文阶段全部创建完成）")]),t._v(" "),e("p",[t._v("作用域在预编译阶段确定，但是作用域链是在执行上下文的创建阶段完全生成的。因为函数在调用时，才会开始创建对应的执行上下文。执行上下文包括了：变量对象、作用域链以及 this的指向")]),t._v(" "),e("h2",{attrs:{id:"闭包-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包-2","aria-hidden":"true"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),e("pre",[e("code",[t._v("函数嵌套函数时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局环境下可访问，就形成了闭包。\n闭包的好处：\n  1. 实现模块化\n  2. 私有化变量\n  3. 公共变量\n  4. 做缓存\n")])]),t._v(" "),e("h2",{attrs:{id:"内存管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存管理","aria-hidden":"true"}},[t._v("#")]),t._v(" 内存管理")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("栈空间")]),t._v(" 由操作系统自动分配释放，存放函数的参数值，局部变量的值，")])]),t._v(" "),e("pre",[e("code",[t._v("    **堆空间**  一般由开发者分配释放，这部分空间就要考虑垃圾回收问题。\n")])]),t._v(" "),e("p",[t._v("**对于分配内存和读写内存的行为所有语言都较为一致，但释放内存空间在不同语言之间有差异。**例如，JavaScript 依赖宿主浏览器的垃圾回收机制，一般情况下不用程序员操心。但这并不表示万事大吉，某些情况下依然会出现内存泄漏现象。\n设置 null 可以清除")]),t._v(" "),e("h2",{attrs:{id:"实现单例模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现单例模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 实现单例模式")]),t._v(" "),e("blockquote",[e("p",[t._v("保证一个类只有一个实例，并且提供一个访问它的全局访问点。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Person() { this.name = 'lucas' }\nconst getSingleInstance = (function(){\nvar singleInstance\n   return function() {\n    if (singleInstance) {\n    return singleInstance\n         }\n   return singleInstance = new Person()\n         }\n })()\nconst instance1 = new getSingleInstance()\nconst instance2 = new getSingleInstance()\n")])])]),e("h2",{attrs:{id:"实现发布订阅模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现发布订阅模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 实现发布订阅模式")]),t._v(" "),e("h2",{attrs:{id:"实现观察者模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现观察者模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 实现观察者模式")])])},[],!1,null,null,null);a.default=r.exports}}]);